var searchIndex = {};
searchIndex["immutable_chunkmap"] = {"doc":"A cache efficient immutable map with lookup performance equivalent to BTreeMap, and reasonably good insertion performance (for a persistent structure). The `Rc` versions cannot be used by multiple threads at once, but have slightly lower single threaded overhead. Each module is duplicated for rc/arc. e.g. `rc::map` uses `Rc`, `arc::map` uses `Arc`.","items":[[0,"rc","immutable_chunkmap","chunkmap using `Rc` pointers",null,null],[0,"map","immutable_chunkmap::rc","A Map implemented using a cache efficient balanced binary tree",null,null],[3,"Map","immutable_chunkmap::rc::map","This Map uses a similar strategy to BTreeMap to ensure cache efficient performance on modern hardware while still providing log(N) get, insert, and remove operations. # Examples ``` use std::string::String; use self::immutable_chunkmap::rc::map::Map;",null,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"map"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"option"}}],[11,"lt","","",0,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"bool"}}],[11,"le","","",0,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"bool"}}],[11,"gt","","",0,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"bool"}}],[11,"ge","","",0,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"bool"}}],[11,"cmp","","",0,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"ordering"}}],[11,"new","","Create a new empty map",0,{"inputs":[],"output":{"name":"self"}}],[11,"insert_sorted","","This method of insertion can be orders of magnitude faster than inserting elements one by one. Assuming you are inserting a large number of elements relative to the size of the map (1/10 +). Assuming your elements are already sorted, or nearly sorted.",0,null],[11,"insert","","return a new map with (k, v) inserted into it. If k already exists in the old map, the new map will contain the new binding, not the old. This method runs in log(N) time, where N is the size of the map.",0,{"inputs":[{"name":"self"},{"name":"k"},{"name":"v"}],"output":{"name":"self"}}],[11,"get","","lookup the mapping for k. If it doesn't exist return None. Runs in log(N) time where N is the size of the map.",0,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"option"}}],[11,"remove","","return a new map with the mapping under k removed. Runs in log(N) time, where N is the size of the map",0,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"self"}}],[11,"length","","get the number of elements in the map O(1)",0,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[0,"arc","immutable_chunkmap","chunkmap using `Arc` pointers",null,null],[0,"map","immutable_chunkmap::arc","A Map implemented using a cache efficient balanced binary tree",null,null],[3,"Map","immutable_chunkmap::arc::map","This Map uses a similar strategy to BTreeMap to ensure cache efficient performance on modern hardware while still providing log(N) get, insert, and remove operations. # Examples ``` use std::string::String; use self::immutable_chunkmap::rc::map::Map;",null,null],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"map"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"option"}}],[11,"lt","","",1,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"bool"}}],[11,"le","","",1,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"bool"}}],[11,"gt","","",1,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"bool"}}],[11,"ge","","",1,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"bool"}}],[11,"cmp","","",1,{"inputs":[{"name":"self"},{"name":"map"}],"output":{"name":"ordering"}}],[11,"new","","Create a new empty map",1,{"inputs":[],"output":{"name":"self"}}],[11,"insert_sorted","","This method of insertion can be orders of magnitude faster than inserting elements one by one. Assuming you are inserting a large number of elements relative to the size of the map (1/10 +). Assuming your elements are already sorted, or nearly sorted.",1,null],[11,"insert","","return a new map with (k, v) inserted into it. If k already exists in the old map, the new map will contain the new binding, not the old. This method runs in log(N) time, where N is the size of the map.",1,{"inputs":[{"name":"self"},{"name":"k"},{"name":"v"}],"output":{"name":"self"}}],[11,"get","","lookup the mapping for k. If it doesn't exist return None. Runs in log(N) time where N is the size of the map.",1,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"option"}}],[11,"remove","","return a new map with the mapping under k removed. Runs in log(N) time, where N is the size of the map",1,{"inputs":[{"name":"self"},{"name":"q"}],"output":{"name":"self"}}],[11,"length","","get the number of elements in the map O(1)",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}]],"paths":[[3,"Map"],[3,"Map"]]};
initSearch(searchIndex);
